#ifndef TOPCODER_H 
#define TOPCODER_H

#include <exception>
#include <string>
#include <vector>
#include <iostream>
#include <sstream>
#include <cmath>
#include <cctype>

typedef unsigned int uint;
typedef long long int64;
typedef unsigned long long uint64;
    
namespace TopCoder
{
    class ParseException: public std::exception {
    private:
        std::string message;
    public:
        ParseException(std::string const &message) : message(message) {}
        ParseException() : message("ParseException occurred") {}
        ~ParseException() throw () {}
        virtual const char* what() const throw() { return message.c_str(); }
    };

    void ignore_whitespaces(std::istream &is)
    {
        while (true) {
            int i = is.peek();
            if (isspace(i)) is.ignore(1);
                       else break;
        } 
    } 
    void expect(std::istream &is, char c)
    {
        ignore_whitespaces(is);
        char cc; is.get(cc);
        if (cc != c) {
            std::ostringstream oss;
            oss << "ParseException occurred  ";
            oss << "(Expected '" << c << "', got '" << cc << "')";
            throw ParseException(oss.str());
        }
    }
    void next(std::istream &is)
    {
        ignore_whitespaces(is);
        expect(is, ',');
    } 

    void read(std::istream &is, int &i) { is >> i; }
    void read(std::istream &is, int64 &l) { is >> l; }
    void read(std::istream &is, float &f) { is >> f; }
    void read(std::istream &is, double &d) { is >> d; }
    void read(std::istream &is, char &c)
    { 
        expect(is, '\'');
        is.get(c);
        if (c == '\'') c = 0;
                  else expect(is, '\'');
    }
    void read(std::istream &is, std::string &s) 
    { 
        expect(is, '"');
        std::ostringstream oss;    
        while (is.good())
        {
            char c; is.get(c);
            if (c == '\\') {
                char cc; is.get(cc);
                oss << cc;
            } else if (c == '"') break;
                   else oss << c;
        }
        s = oss.str();
    }
    template <typename T>
    void read(std::istream &is, std::vector<T> &v)
    {
        v.clear();
        expect(is, '['); 
        ignore_whitespaces(is);
        int i = is.peek(); 
        if (i == ']') {
            is.ignore(1);
            return;
        }
        while (is.good()) { 
            T e; read(is, e); v.push_back(e);
            ignore_whitespaces(is); char c; is.get(c);
            if (c == ']') break;
            else if (c != ',') {
                std::ostringstream oss;
                oss << "ParseException occurred ";
                oss << "(Expected ',' or ']', got '" << c << "')";
                throw ParseException(oss.str());
            }
        } 
    } 

    void show(std::ostream &os, int i) { os << i; }
    void show(std::ostream &os, int64 l) { os << l; }
    void show(std::ostream &os, float f) 
    { 
        os.precision(8);
        os << f; 
    }
    void show(std::ostream &os, double d) 
    { 
        os.precision(16);
        os << d; 
    }
    void show(std::ostream &os, char c) 
    { 
        os << '\'' << c << '\'';
    }
    void show(std::ostream &os, std::string const &s)
    { 
        os << '"' << s << '"';
    }
    template <typename T>
    void show(std::ostream &os, std::vector<T> const &v)
    {
        typedef typename std::vector<T>::const_iterator Iterator;
        bool first = true;
        os << '[';
        for (Iterator it = v.begin(); it != v.end(); ++it) {            
            if (!first) os << ',';
            show(os, *it);
            first = false;
        }
        os << ']';
    }

    bool same(int i, int j) { return i == j; }
    bool same(int64 i, int64 j) { return i == j; }
    bool same(char i, char j) { return i == j; }
    bool same(std::string const &s1, std::string const &s2) { return s1 == s2; }
    bool same(float x, float y) 
    { 
        return std::abs(x - y) < 1e-5;
    }
    bool same(double x, double y)
    { 
        return std::abs(x - y) < 1e-9;
    } 
    template <typename T>
    bool same(std::vector<T> const &v1, std::vector<T> const &v2)
    { 
        typedef typename std::vector<T>::const_iterator Iterator;
        Iterator i1 = v1.begin(),
                 i2 = v2.begin();
        while (true) {
            if (i1 == v1.end()) return i2 == v2.end();
            if (i2 == v2.end()) return false;
            if (!same(*i1++, *i2++)) return false;
        }
    }
}

#endif /* TOPCODER_H */ 
